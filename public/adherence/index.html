<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Allstar — Agent Adherence</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      /* brand (hub-matched) */
      --brand:#e11d48; --brand-ink:#fff;

      /* light theme palette (dark mode later) */
      --bg:#ffffff; --ink:#0f172a; --muted:#6b7280; --line:#e5e7eb; --card:#ffffff;
      --shadow:0 10px 25px rgba(17,24,39,.08);
      --radius:18px;

      /* status colors (more distinct oranges/yellows) */
      --st-available:#10b981;  /* green */
      --st-bathroom:#d97706;   /* amber-600 (darker than break) */
      --st-break:#f59e0b;      /* amber-500 */
      --st-lunch:#fb923c;      /* orange-400 */
      --st-training:#8b5cf6;   /* violet-500 */
      --st-meeting:#3b82f6;    /* blue-500 */
      --st-offline:#9ca3af;    /* gray-400 */

      --diff:rgba(239,68,68,.35); /* red-500 overlay for mismatch */
    }
    *{box-sizing:border-box}
    body{margin:0;font:15px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--ink)}
    a{color:var(--brand);text-decoration:none}
    .header{position:sticky;top:0;z-index:10;backdrop-filter:blur(6px);background:rgba(255,255,255,.9);border-bottom:1px solid var(--line)}
    .header-inner{display:flex;align-items:center;gap:14px;padding:14px 20px}
    .logo{font-weight:900;letter-spacing:.3px;color:var(--brand);font-size:18px}
    .me{margin-left:auto;color:var(--muted)}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid var(--line);background:#fff;cursor:pointer;color:inherit;text-decoration:none;box-shadow:var(--shadow)}
    .btn:hover{background:#fafafa}
    .btn-brand{background:var(--brand);border-color:transparent;color:var(--brand-ink)}
    .container{max-width:1150px;margin:0 auto;padding:22px}
    .grid{display:grid;gap:20px}
    .grid-2{grid-template-columns:2fr 1fr}
    .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);padding:18px;box-shadow:var(--shadow)}
    .muted{color:var(--muted)}
    .title-row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    .h1{font-size:22px;font-weight:800;margin:0}
    .h2{font-size:16px;font-weight:700;margin:0}
    .pill{display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;border:1px solid var(--line);background:#f8fafc;font-size:12px}
    .row{display:flex;align-items:center;gap:10px}
    .btns{display:flex;flex-wrap:wrap;gap:10px}
    .status-btn{border:0;color:#fff;border-radius:12px;padding:8px 12px;cursor:pointer;box-shadow:var(--shadow)}
    .status-btn:hover{filter:brightness(.97)}
    .small{font-size:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .list{max-height:220px;overflow:auto;border-top:1px solid var(--line);margin-top:8px}
    .li{display:flex;align-items:center;justify-content:space-between;padding:8px 0;border-bottom:1px solid var(--line)}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:8px}

    /* dual bars */
    .timeline-wrap{position:relative;display:grid;gap:10px}
    .bar-row{display:flex;align-items:center;gap:12px}
    .rowlabel{width:7.2rem;color:var(--muted);font-size:12px}
    .gridbar{height:22px;border-radius:10px;overflow:hidden;background:#f3f4f6;flex:1;position:relative}
    .seg{height:100%;display:inline-block;position:relative}
    .seg.diff::after{content:"";position:absolute;inset:0;background:var(--diff)} /* red overlay for mismatch */
    .nowline{position:absolute;top:-6px;bottom:-6px;width:2px;background:#111827}
    .stat-big{font-size:32px;font-weight:800}
    .stat-sub{color:var(--muted)}

    /* status classes for segments & buttons */
    .st-available{background:var(--st-available)}
    .st-bathroom{background:var(--st-bathroom)}
    .st-break{background:var(--st-break)}
    .st-lunch{background:var(--st-lunch)}
    .st-training{background:var(--st-training)}
    .st-meeting{background:var(--st-meeting)}
    .st-offline{background:var(--st-offline)}

    @media (max-width: 1000px){
      .grid-2{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-inner">
      <div class="logo">ALLSTAR — Adherence</div>
      <a class="btn" href="/hub.html">← Back to Hub</a>
      <div id="me" class="me">Loading…</div>
    </div>
  </div>

  <div class="container">
    <div class="grid grid-2">
      <!-- Left: Today -->
      <div class="card">
        <div class="title-row">
          <div class="row">
            <h1 class="h1">Today</h1>
            <span id="today" class="pill"></span>
          </div>
          <div class="row">
            <div class="stat-big" id="adhPct">100%</div>
            <div class="stat-sub" id="adhBreakdown">in: 0m · out: 0m</div>
          </div>
        </div>

        <div id="bars" class="timeline-wrap" style="margin-top:6px"></div>

        <div class="card" style="margin-top:16px">
          <div class="row" style="justify-content:space-between">
            <h2 class="h2">Set status</h2>
            <div class="small muted mono" id="since">Status: — · 00:00:00</div>
          </div>
          <div class="btns" id="statusBtns" style="margin-top:10px"></div>

          <div style="margin-top:14px">
            <div class="h2" style="margin-bottom:6px">Recent switches</div>
            <div id="recent" class="list small"></div>
          </div>
        </div>
      </div>

      <!-- Right: My overview (fast glance) -->
      <div class="card">
        <div class="title-row">
          <h2 class="h2">My Overview</h2>
          <span class="muted small" id="lastSync">—</span>
        </div>
        <div class="small muted">Live adherence and timeline update every second; server sync every 15s.</div>
        <div id="aux" class="small" style="margin-top:12px"></div>
      </div>
    </div>
  </div>

  <script>
  // -------- CONFIG / STATUS SET --------
  const STATUS = [
    { key:'available', label:'Available', cls:'st-available' },
    { key:'bathroom',  label:'Bathroom',  cls:'st-bathroom'  },
    { key:'break',     label:'Break',     cls:'st-break'     },
    { key:'lunch',     label:'Lunch',     cls:'st-lunch'     },
    { key:'training',  label:'Training',  cls:'st-training'  },
    { key:'meeting',   label:'Meeting',   cls:'st-meeting'   },
    { key:'offline',   label:'Offline',   cls:'st-offline'   },
  ];
  const STATUS_MAP = Object.fromEntries(STATUS.map(s=>[s.key,s]));

  // -------- API HELPERS --------
  async function api(path, init={}){
    const res = await fetch(path, { credentials:'include', cache:'no-store', ...init });
    if (res.status===204) return null;
    const ct = res.headers.get('content-type')||'';
    const body = ct.includes('application/json') ? await res.json() : await res.text();
    if (!res.ok) throw new Error((body && body.error) || ('HTTP '+res.status));
    return body;
  }
  const apiWhoami   = ()=> api('/api/whoami');
  const apiSchedule = (u,d)=> api(`/api/schedules?user=${encodeURIComponent(u)}&date=${encodeURIComponent(d)}`);
  const apiEvents   = (u,from,to)=> api(`/api/events?user=${encodeURIComponent(u)}&from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}`);
  const apiPostEvent= (status)=> api('/api/events',{ method:'POST', headers:{'content-type':'application/json'}, body:JSON.stringify({ status }) });

  // -------- UTIL --------
  const pad=n=>String(n).padStart(2,'0');
  const toISODate = (d)=> (d instanceof Date ? d : new Date(d)).toISOString().slice(0,10);
  const fmtDur = (mins)=> (mins<60) ? `${mins}m` : `${Math.floor(mins/60)}h ${mins%60? (mins%60+'m') : ''}`;
  const fmtTS = (ms)=>{ const d=new Date(ms); return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; };

  function statusLabel(k){ return (STATUS_MAP[k]||{}).label || k || '—'; }
  function statusClass(k){ return (STATUS_MAP[k]||{}).cls || 'st-offline'; }

  function minuteOfDay(msUTC){ const d=new Date(msUTC); return d.getUTCHours()*60 + d.getUTCMinutes(); }

  // Compute adherence up to "now" (UTC minutes), only where schedule defines expected
  function calcAdherence(dateISO, blocks, events){
    if (!blocks.length) return { pct:100, inMin:0, outMin:0, byStatus:{}, lines:[] };

    const dayStart = Date.parse(dateISO + 'T00:00:00Z');
    const startMin = Math.min(...blocks.map(b=>b.start));
    const endMin   = Math.max(...blocks.map(b=>b.end));
    const nowMin   = Math.min(endMin, Math.max(startMin, minuteOfDay(Date.now())));

    // walk events → (minute -> current status)
    const evSorted = [...events].sort((a,b)=> Number(a.ts)-Number(b.ts));
    let idx=0, cur = evSorted.length ? evSorted[0].status : null;

    // timeline lines & totals by status (actual)
    const lines=[], byStatus={};
    let spanStatus = cur, spanStart = startMin;

    let inMin=0, outMin=0;
    for (let m=startMin; m<=nowMin; m++){
      const ms = dayStart + m*60000;
      while (idx+1 < evSorted.length && Number(evSorted[idx+1].ts) <= ms) {
        // close previous span at this minute
        if (spanStatus && spanStart < m){
          const dur = m - spanStart;
          byStatus[spanStatus] = (byStatus[spanStatus]||0) + dur;
          lines.push(`${fmtTS(dayStart + spanStart*60000)} ${statusLabel(spanStatus)} ${fmtDur(dur)}`);
        }
        idx++; cur = evSorted[idx].status;
        spanStatus = cur; spanStart = m;
      }
      // adherence minute-by-minute
      const exp = blocks.find(b=> m>=b.start && m<b.end);
      if (!exp) continue; // unscheduled minutes don't count
      if (cur && cur===exp.status) inMin++;
      else outMin++;
    }
    // close last span to endMin for display purposes
    if (spanStatus && spanStart < endMin){
      const dur = (Math.max(nowMin,spanStart)) - spanStart;
      if (dur > 0) {
        byStatus[spanStatus] = (byStatus[spanStatus]||0) + dur;
        lines.push(`${fmtTS(dayStart + spanStart*60000)} ${statusLabel(spanStatus)} ${fmtDur(dur)}`);
      }
    }
    const total = inMin + outMin;
    const pct = total ? (inMin/total*100) : 100;
    return { pct, inMin, outMin, byStatus, lines };
  }

  // Build the two bars + a red overlay on Actual segments that differ from the scheduled status
  function buildDualBars(dateISO, blocks, events){
    const wrap = document.createElement('div');
    wrap.className='timeline-wrap';

    if (!blocks.length){
      wrap.innerHTML = `<div class="muted small">No schedule for today.</div>`;
      return wrap;
    }

    const dayStart = Date.parse(dateISO + 'T00:00:00Z');
    const startMin = Math.min(...blocks.map(b=>b.start));
    const endMin   = Math.max(...blocks.map(b=>b.end));
    const total    = endMin - startMin || 1;

    function blocksToSegs() {
      return blocks.map(b => ({ status:b.status, start:b.start, width:b.end-b.start }));
    }

    function eventsToSegs() {
      const segs=[];
      const sorted = [...events].sort((a,b)=> Number(a.ts)-Number(b.ts));
      let cur = sorted.length ? sorted[0].status : null;
      let cursor = startMin;
      for (let i=0; i<sorted.length; i++){
        const p = Math.max(startMin, Math.min(endMin, Math.floor((Number(sorted[i].ts)-dayStart)/60000)));
        if (p>cursor){ segs.push({ status:cur, start:cursor, width:p-cursor }); }
        cursor = p; cur = sorted[i].status;
      }
      if (cursor<endMin) segs.push({ status:cur, start:cursor, width:endMin-cursor });
      return segs;
    }

    const proj = blocksToSegs();
    const act  = eventsToSegs();

    function row(segs, compare){
      const bar = document.createElement('div'); bar.className='gridbar';
      segs.forEach(s=>{
        const w = (s.width/total*100).toFixed(4)+'%';
        const div = document.createElement('div');
        let diff=false;
        if (compare){
          // probe mid-point to decide mismatch; only count if schedule expects something
          const probe = s.start + Math.max(1, Math.floor(s.width/2));
          const exp = blocks.find(b => probe>=b.start && probe<b.end);
          diff = !!(exp && s.status && exp.status !== s.status) || (!!exp && !s.status);
        }
        div.className = `seg ${s.status ? statusClass(s.status) : 'st-offline'} ${compare && diff ? 'diff' : ''}`;
        div.style.width = w;
        bar.appendChild(div);
      });
      return bar;
    }

    const top = document.createElement('div'); top.className='bar-row';
    top.appendChild(el('div',{class:'rowlabel'},'Projected'));
    top.appendChild(row(proj,false));
    wrap.appendChild(top);

    const bottom = document.createElement('div'); bottom.className='bar-row';
    bottom.appendChild(el('div',{class:'rowlabel'},'Actual'));
    bottom.appendChild(row(act,true));
    wrap.appendChild(bottom);

    // nowline
    const now = Date.now();
    const nowMin = Math.floor((now - dayStart)/60000);
    const nowPct = Math.max(0, Math.min(100, ((nowMin-startMin)/(total))*100));
    const nl = document.createElement('div');
    nl.className='nowline';
    nl.style.left = nowPct+'%';
    bottom.lastChild.appendChild(nl);

    return wrap;
  }

  // tiny element helper
  function el(tag, attrs, ...children){
    const n=document.createElement(tag);
    if (attrs) for (const [k,v] of Object.entries(attrs)){
      if (k==='class') n.className=v;
      else if (k==='style') Object.assign(n.style,v);
      else if (k.startsWith('on')) n.addEventListener(k.slice(2), v);
      else n.setAttribute(k,v);
    }
    children.flat().forEach(c=> n.appendChild(c.nodeType?c:document.createTextNode(String(c))));
    return n;
  }

  // -------- PAGE STATE --------
  const STATE = {
    me:null,
    date: toISODate(new Date()),
    schedule: [],   // [{status, start, end}]
    events: [],     // [{status, ts}]
    timers: []
  };
  function clearTimers(){ STATE.timers.forEach(id=>clearInterval(id)); STATE.timers=[]; }

  // -------- RENDER --------
  function renderHeader(){
    const meEl = document.getElementById('me');
    meEl.textContent = STATE.me?.username ? `${STATE.me.username} · ${STATE.me.role}` : 'Signed in';
    document.getElementById('today').textContent = STATE.date;
  }

  function renderBars(){
    const host = document.getElementById('bars');
    host.innerHTML='';
    host.appendChild(buildDualBars(STATE.date, STATE.schedule, STATE.events));
  }

  function renderStats(){
    const d = calcAdherence(STATE.date, STATE.schedule, STATE.events);
    document.getElementById('adhPct').textContent = Math.round(d.pct)+'%';
    document.getElementById('adhBreakdown').textContent = `in: ${fmtDur(d.inMin)} · out: ${fmtDur(d.outMin)}`;

    // AUX breakdown
    const aux = document.getElementById('aux');
    aux.innerHTML = '<div class="h2" style="margin:0 0 6px">AUX breakdown (actual)</div>';
    if (!Object.keys(d.byStatus).length) {
      aux.innerHTML += '<div class="muted small">No activity yet.</div>';
    } else {
      for (const [k,mins] of Object.entries(d.byStatus)){
        const row = el('div',{class:'row',style:{margin:'4px 0'}},
          el('span',{class:'dot',style:{background:getComputedStyleColor(statusClass(k))}}),
          el('span',{}, `${statusLabel(k)} — ${fmtDur(mins)}`)
        );
        aux.appendChild(row);
      }
    }

    // live "since"
    const last = [...STATE.events].sort((a,b)=>Number(b.ts)-Number(a.ts))[0];
    if (last){
      const sinceEl = document.getElementById('since');
      const tick = ()=>{
        const secs = Math.floor((Date.now() - Number(last.ts))/1000);
        const h=pad(Math.floor(secs/3600)), m=pad(Math.floor((secs%3600)/60)), s=pad(secs%60);
        sinceEl.textContent = `Status: ${statusLabel(last.status)} · ${h}:${m}:${s}`;
      };
      tick();
    } else {
      document.getElementById('since').textContent = 'Status: — · 00:00:00';
    }
  }

  function renderRecent(){
    const host = document.getElementById('recent');
    host.innerHTML='';
    const items = [...STATE.events].sort((a,b)=>Number(b.ts)-Number(a.ts)).slice(0,12);
    if (!items.length){
      host.innerHTML = '<div class="muted small" style="padding:8px 0">No switches yet.</div>';
      return;
    }
    items.forEach(ev=>{
      const row = el('div',{class:'li'},
        el('div',{}, el('span',{class:'dot',style:{background:getComputedStyleColor(statusClass(ev.status))}}), statusLabel(ev.status)),
        el('div',{class:'muted mono'}, fmtTS(Number(ev.ts)))
      );
      host.appendChild(row);
    });
  }

  function renderStatusButtons(){
    const host = document.getElementById('statusBtns');
    host.innerHTML='';
    STATUS.forEach(s=>{
      const b = document.createElement('button');
      b.className = `status-btn ${s.cls}`;
      b.textContent = s.label;
      b.onclick = async ()=>{
        // optimistic local add
        STATE.events.push({ status:s.key, ts: Date.now() });
        renderBars(); renderStats(); renderRecent();
        try{ await apiPostEvent(s.key); }catch(e){ console.warn('postEvent failed', e); }
      };
      host.appendChild(b);
    });
  }

  function getComputedStyleColor(cls){
    const map={
      'st-available':'var(--st-available)',
      'st-bathroom':'var(--st-bathroom)',
      'st-break':'var(--st-break)',
      'st-lunch':'var(--st-lunch)',
      'st-training':'var(--st-training)',
      'st-meeting':'var(--st-meeting)',
      'st-offline':'var(--st-offline)',
    };
    // Compute to actual value:
    const probe = document.createElement('div');
    probe.style.display='none';
    probe.className=cls;
    document.body.appendChild(probe);
    const c = getComputedStyle(probe).backgroundColor;
    probe.remove();
    // fallback to CSS var if computed isn't resolved
    return c || map[cls] || '#9ca3af';
  }

  // -------- BOOT --------
  (async function init(){
    try{
      const who = await apiWhoami();
      if (!who?.authed && who?.me) { STATE.me = who.me; }
      if (who?.me) STATE.me = who.me;
      // support both shapes: {authed:true,me:{...}} or direct {id,username,role}
      if (!STATE.me?.username && who?.username) STATE.me = who;

      if (!STATE.me?.username) { location.replace('/'); return; }
      renderHeader();

      document.getElementById('today').textContent = STATE.date;

      // load schedule + events
      const [sched, ev] = await Promise.all([
        apiSchedule(STATE.me.username, STATE.date),
        apiEvents(STATE.me.username, STATE.date, STATE.date),
      ]);

      // Normalize schedule shape
      const blocks = (sched?.blocks||[]).map(b=>({
        status: b.status,
        start:  typeof b.start === 'number' ? b.start : hhmmToMinute(b.start),
        end:    typeof b.end   === 'number' ? b.end   : hhmmToMinute(b.end),
      })).sort((a,b)=> a.start-b.start);

      STATE.schedule = blocks;
      STATE.events   = Array.isArray(ev) ? ev : [];

      renderStatusButtons();
      renderBars(); renderStats(); renderRecent();
      document.getElementById('lastSync').textContent = 'Synced now';

      // 1s UI tick
      STATE.timers.push(setInterval(()=>{
        renderBars(); renderStats();
      }, 1000));

      // 15s data refresh
      STATE.timers.push(setInterval(async()=>{
        try{
          const [sched2, ev2] = await Promise.all([
            apiSchedule(STATE.me.username, STATE.date),
            apiEvents(STATE.me.username, STATE.date, STATE.date),
          ]);
          STATE.schedule = (sched2?.blocks||[]).map(b=>({
            status:b.status,
            start: typeof b.start === 'number' ? b.start : hhmmToMinute(b.start),
            end:   typeof b.end   === 'number' ? b.end   : hhmmToMinute(b.end),
          })).sort((a,b)=> a.start-b.start);
          STATE.events = Array.isArray(ev2) ? ev2 : [];
          document.getElementById('lastSync').textContent =
            'Synced ' + new Date().toLocaleTimeString();
        }catch(e){ /* never hard-fail UI */ }
      }, 15000));

    }catch(e){
      console.error(e);
      location.replace('/');
    }
  })();

  function hhmmToMinute(s){
    if (typeof s === 'number') return s|0;
    const [h,m] = String(s||'').split(':').map(Number);
    return ((h|0)*60 + (m|0))|0;
  }
  </script>
</body>
</html>
