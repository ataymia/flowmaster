<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Adherence — Allstar Agent Hub</title>
<link rel="stylesheet" href="/theme.css"/>
</head>
<body>
<div class="header"><div class="wrap brand">
  <a class="tab" href="/hub">Hub</a>
  <a class="tab" href="/flowmaster/">Flowmaster</a>
  <a class="tab active" href="/adherence/">Schedule</a>
  <span id="meta" class="pill" style="margin-left:auto">Checking…</span>
  <button id="impersonate" class="btn" style="display:none;margin-left:8px">View as Agent</button>
</div></div>

<div class="wrap" id="root"></div>

<script>
/* --------------- small helpers --------------- */
const el=(t,a,...c)=>{const n=document.createElement(t);if(a)Object.entries(a).forEach(([k,v])=>k==='class'?n.className=v:k==='style'?Object.assign(n.style,v):k.startsWith('on')?n.addEventListener(k.slice(2),v):n.setAttribute(k,v));c.flat().forEach(x=>n.append(x?.nodeType?x:document.createTextNode(x??'')));return n;}
const qs=s=>document.querySelector(s), qsa=s=>Array.from(document.querySelectorAll(s));
const pad=n=>String(n).padStart(2,'0');
const isoDate=d=> (d instanceof Date?d:new Date(d)).toISOString().slice(0,10);
const toHM=m=>`${pad(Math.floor(m/60))}:${pad(m%60)}`;
const fromHM=s=>{const[h,m]=s.split(':').map(Number);return h*60+m;};
const COLORS = {available:'st-available', bathroom:'st-bathroom', break:'st-break', lunch:'st-lunch', training:'st-training', meeting:'st-meeting', offline:'st-offline'};
const LABELS = {available:'Available', bathroom:'Bathroom', break:'Break', lunch:'Lunch', training:'Training', meeting:'Meeting', offline:'Offline'};
const STATUSES = Object.keys(COLORS);

/* --------------- api via Pages Functions --------------- */
async function api(path,opts={}){
  const r = await fetch(path,Object.assign({credentials:'include'},opts));
  const ct=r.headers.get('content-type')||'';
  const t=ct.includes('json')?await r.json():await r.text();
  if(!r.ok) throw Object.assign(new Error(typeof t==='string'?t:(t.error||('HTTP '+r.status))),{status:r.status,body:t});
  return t;
}
const whoami = ()=> api('/api/whoami');
const postEvent = (status)=> api('/api/events',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({status})});
const listEvents=(user,from,to)=> api('/api/events?'+new URLSearchParams({user,from,to}));
const getSchedule=(user,date)=> api('/api/schedules?'+new URLSearchParams({user,date}));
const saveSchedule=(user,date,blocks)=> api('/api/schedules',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username:user,date,blocks})});

/* --------------- shared visuals --------------- */
function buildBars(date, scheduleBlocks, events){
  const wrap=el('div',{style:{position:'relative'}});
  if(!scheduleBlocks?.length){
    wrap.append(el('div',{class:'help'},'No schedule blocks for this day.'));
    return wrap;
  }
  const startMin=Math.min(...scheduleBlocks.map(b=>b.start));
  const endMin=Math.max(...scheduleBlocks.map(b=>b.end));
  const total=endMin-startMin||1;
  const dayStart=Date.parse(date+'T00:00:00');

  const proj = scheduleBlocks.map(b=>({status:b.status,start:b.start,width:(b.end-b.start)}));

  function eventsToSegs(){
    const rows=[...events||[]].sort((a,b)=>a.ts-b.ts);
    let segs=[], cur=rows[0]?.status||null, cursor=startMin;
    const pts=rows.map(ev=>Math.max(startMin,Math.min(endMin,Math.floor((Number(ev.ts)-dayStart)/60000))));
    for(let i=0;i<pts.length;i++){const p=pts[i]; if(p>cursor) segs.push({status:cur,start:cursor,width:p-cursor}); cursor=p; cur=rows[i].status;}
    if(cursor<endMin) segs.push({status:cur,start:cursor,width:endMin-cursor});
    return segs;
  }

  function row(segs, compare){
    const bar=el('div',{class:'gridbar'});
    segs.forEach(s=>{
      const w=(s.width/total*100)+'%';
      let diff=false;
      if(compare){
        const mid=s.start+Math.max(1,Math.floor(s.width/2));
        const exp=scheduleBlocks.find(b=> mid>=b.start && mid<b.end);
        diff = !!(exp && s.status && exp.status!==s.status);
      }
      bar.append(el('div',{class:`seg ${s.status?COLORS[s.status]:''} ${compare&&diff?'diff':''}`,style:{width:w}}));
    });
    return bar;
  }

  const projRow=row(proj,false);
  const actRow=row(eventsToSegs(),true);
  wrap.append(el('div',{style:{display:'grid',gap:'6px'}},
           el('div',{}, el('div',{class:'help'},'Projected'), projRow),
           el('div',{}, el('div',{class:'help'},'Actual'), actRow)));

  // realtime now-line
  const now=Date.now(), nowMin=Math.floor((now-dayStart)/60000);
  const nowPct=Math.max(0,Math.min(100,((nowMin-startMin)/total)*100));
  wrap.append(el('div',{class:'nowline',style:{left:nowPct+'%'}}));

  // live update: only rebuild actual row (efficient enough)
  const tick=()=> {
    const newAct=row(eventsToSegs(),true);
    actRow.replaceWith(newAct);
    const ms=Date.now(), nMin=Math.floor((ms-dayStart)/60000);
    const p=Math.max(0,Math.min(100,((nMin-startMin)/total)*100));
    wrap.querySelector('.nowline').style.left=p+'%';
  };
  const id=setInterval(tick,1000);
  wrap._cleanup = ()=>clearInterval(id);
  return wrap;
}

function computeAdherence(date, blocks, events){
  if(!blocks?.length) return {pct:100,inMin:0,outMin:0,by:{}};
  const dayStart=Date.parse(date+'T00:00:00');
  const startMin=Math.min(...blocks.map(b=>b.start));
  const endMin=Math.max(...blocks.map(b=>b.end));
  let idx=0, cur=events?.[0]?.status||null;
  const nowMin=Math.min(Math.max(startMin,Math.floor((Date.now()-dayStart)/60000)), endMin);
  let inMin=0,outMin=0, by={};
  for(let m=startMin;m<nowMin;m++){
    const ms=dayStart+m*60000;
    while(idx+1<(events?.length||0) && Number(events[idx+1].ts)<=ms){ idx++; cur=events[idx].status; }
    const exp=blocks.find(b=> m>=b.start && m<b.end);
    if(!exp) continue;
    if(cur===exp.status){ inMin++; by[cur]=(by[cur]||0)+1; } else outMin++;
  }
  const total=inMin+outMin; const pct = total? Math.round(inMin/total*100):100;
  return {pct,inMin,outMin,by};
}

/* --------------- Agent View --------------- */
function mountAgent(me){
  const root=qs('#root'); root.innerHTML='';
  qs('#meta').textContent = `${me.username} · ${me.role}`;

  const today=isoDate(new Date());
  const statusBtns=el('div',{class:'grid',style:{gridTemplateColumns:'repeat(auto-fit,minmax(120px,1fr))',gap:'8px',marginTop:'8px'}},
    ...STATUSES.map(k=> el('button',{class:'btn',style:{background:'var(--'+COLORS[k].slice(3)+')',color:'#0a0f1a'},onclick:()=>switchTo(k)},LABELS[k])));

  const card=el('div',{class:'card'},
    el('div',{style:{display:'flex',justifyContent:'space-between',alignItems:'baseline',gap:'8px'}},
      el('h2',{},'Today'), el('div',{class:'help'},today)),
    el('div',{id:'bars',style:{marginTop:'10px'}}),
    el('div',{id:'stats',style:{marginTop:'10px'}},''),
    el('div',{style:{marginTop:'14px'}}, el('h3',{},'Set status'), statusBtns),
    el('div',{style:{marginTop:'14px'}}, el('h4',{},'Recent switches'), el('div',{id:'recent',class:'card',style:{padding:'8px'}}))
  );
  root.append(card);

  const SCHEDULE={blocks:[]}, EVENTS={list:[]};
  let cleaner=()=>{};

  function redraw(){
    const barsHost=qs('#bars'); barsHost.innerHTML='';
    const wrap=buildBars(today,SCHEDULE.blocks,EVENTS.list); barsHost.append(wrap);
    cleaner=wrap._cleanup||(()=>{});
    const d=computeAdherence(today,SCHEDULE.blocks,EVENTS.list);
    qs('#stats').textContent=`Adherence: ${d.pct}% · in ${d.inMin}m · out ${d.outMin}m`;
    const host=qs('#recent'); host.innerHTML='';
    [...EVENTS.list].slice(-12).reverse().forEach(ev=> host.append(el('div',{style:{borderTop:'1px solid var(--line)',padding:'6px 0'}}, `${new Date(ev.ts).toLocaleTimeString()} — ${LABELS[ev.status]}`)));
  }

  async function refresh(){
    try{
      const s=await getSchedule(me.username,today); SCHEDULE.blocks=s?.blocks||[];
      const ev=await listEvents(me.username,today,today); EVENTS.list=Array.isArray(ev)?ev:[];
      redraw();
    }catch(e){ console.warn(e); }
  }
  function switchTo(status){
    EVENTS.list.push({status,ts:Date.now()}); redraw();
    postEvent(status).catch(()=>{}); // fire & forget
  }

  refresh(); const t1=setInterval(()=>{ try{cleaner();}catch{} redraw(); },1000);
  const t2=setInterval(refresh,15000);
  root._cleanup = ()=>{ clearInterval(t1); clearInterval(t2); try{cleaner();}catch{} };
}

/* --------------- Admin View --------------- */
function mountAdmin(me){
  const root=qs('#root'); root.innerHTML='';
  qs('#meta').textContent = `${me.username} · ${me.role}`;
  qs('#impersonate').style.display='inline-flex';
  qs('#impersonate').onclick=()=>mountAgent(me);

  const tabs=el('div',{class:'tabs',style:{marginBottom:'10px'}},
    el('a',{href:'#',class:'tab active',onClick:(e)=>switchTab(e,'schedule')},'Schedule'),
    el('a',{href:'#',class:'tab',onClick:(e)=>switchTab(e,'live')},'Live Status'),
    el('a',{href:'#',class:'tab',onClick:(e)=>switchTab(e,'hist')},'History')
  );
  const pane=el('div',{}, el('div',{id:'pane'}));
  root.append(tabs,pane);

  function activate(name){
    qsa('.tabs .tab').forEach(a=>a.classList.remove('active'));
    qsa('.tabs .tab').find(a=>a.textContent.toLowerCase().includes(name)).classList.add('active');
  }
  function switchTab(ev,name){ ev.preventDefault(); ({schedule:showSchedule,live:showLive,hist:showHistory})[name](); activate(name); }

  /* --- Schedule tab --- */
  async function showSchedule(){
    const host=qs('#pane'); host.innerHTML='';
    const hdr=el('div',{class:'grid grid-2'},
      el('div',{class:'card'}, el('div',{class:'label'},'Agent'),
        el('select',{id:'selUser',class:'field'}, el('option',{value:''},'Pick a user'))),
      el('div',{class:'card'}, el('div',{class:'label'},'Date'),
        el('input',{id:'day',class:'field',type:'date',value:isoDate(new Date())})));
    const body=el('div',{class:'grid grid-2',style:{marginTop:'10px'}},
      el('div',{class:'card'}, el('h3',{},'Schedule Blocks'), el('div',{id:'blocks'}), el('div',{style:{marginTop:'10px'}},
        el('button',{class:'btn',onclick:addBlock},'+ Block'),
        ' ',
        el('button',{id:'saveBtn',class:'btn-brand',disabled:true,onclick:save},'Save to Server'))),
      el('div',{class:'card'}, el('h3',{},'Daily Overview'),
        el('div',{id:'bars',style:{marginTop:'10px'}}),
        el('div',{id:'pct',class:'help',style:{marginTop:'8px'}})));
    host.append(hdr,body);

    const SELECTED={user:'',date:isoDate(new Date())}, BLOCKS={list:[]}, EVENTS={list:[]};

    async function loadUsers(){
      // show only agents for admins, and everyone for superadmin; leverage your Worker filter
      // (listUsers is behind auth in Worker; create a proxy later if you want. For now, type a username.)
      // If you want the UI to list users from server, add a /api/users proxy similar to schedules/events.
      const sel=qs('#selUser'); sel.innerHTML='<option value="">Pick a user</option>';
      // Quick fallback: allow manual entry
      sel.append(el('option',{value:me.username},me.username+' (me)'));
    }
    function addBlock(){
      BLOCKS.list.push({status:'available',start:480,end:540});
      renderBlocks(); renderDay();
    }
    function renderBlocks(){
      const host=qs('#blocks'); host.innerHTML='';
      BLOCKS.list.forEach((b,i)=> host.append(
        el('div',{style:{display:'flex',gap:'8px',marginBottom:'8px'}},
          el('select',{class:'field',style:{maxWidth:'160px'},onchange:e=>b.status=e.target.value},
            ...STATUSES.map(k=> el('option',{value:k,selected:k===b.status},LABELS[k]))),
          el('input',{class:'field',style:{maxWidth:'120px'},type:'time',value:toHM(b.start),onchange:e=>b.start=fromHM(e.target.value)}),
          el('span',{},'to'),
          el('input',{class:'field',style:{maxWidth:'120px'},type:'time',value:toHM(b.end),onchange:e=>b.end=fromHM(e.target.value)}),
          el('button',{class:'btn',onclick:()=>{BLOCKS.list.splice(i,1);renderBlocks();renderDay();}},'Remove')
      )); 
    }
    function renderDay(){
      const barsHost=qs('#bars'); barsHost.innerHTML='';
      barsHost.append(buildBars(SELECTED.date,BLOCKS.list,EVENTS.list));
      const d=computeAdherence(SELECTED.date,BLOCKS.list,EVENTS.list);
      qs('#pct').textContent=`Adherence now: ${d.pct}% · in ${d.inMin}m · out ${d.outMin}m`;
      qs('#saveBtn').disabled=!SELECTED.user;
    }

    qs('#selUser').onchange=async e=>{
      SELECTED.user = e.target.value;
      if(!SELECTED.user){ BLOCKS.list=[]; EVENTS.list=[]; renderBlocks(); renderDay(); return; }
      try{
        const s=await getSchedule(SELECTED.user,SELECTED.date); BLOCKS.list=s?.blocks||[];
        const ev=await listEvents(SELECTED.user,SELECTED.date,SELECTED.date); EVENTS.list=Array.isArray(ev)?ev:[];
      }catch{}
      renderBlocks(); renderDay();
    };
    qs('#day').onchange=async e=>{
      SELECTED.date = e.target.value||isoDate(new Date());
      if(!SELECTED.user) return renderDay();
      try{
        const s=await getSchedule(SELECTED.user,SELECTED.date); BLOCKS.list=s?.blocks||[];
        const ev=await listEvents(SELECTED.user,SELECTED.date,SELECTED.date); EVENTS.list=Array.isArray(ev)?ev:[];
      }catch{}
      renderBlocks(); renderDay();
    };

    async function save(){
      try{
        await saveSchedule(SELECTED.user,SELECTED.date,BLOCKS.list);
        alert('Saved');
      }catch(e){
        alert('Save failed: '+(e.body?.error||e.message));
      }
    }
    await loadUsers(); // simple select for now
  }

  /* --- Live Status tab --- */
  async function showLive(){
    const host=qs('#pane'); host.innerHTML='';
    host.append(el('div',{class:'card'},
      el('div',{style:{display:'flex',justifyContent:'space-between'}},
        el('h3',{},'Live Agent Status — Today'), el('div',{class:'help'},isoDate(new Date()))),
      el('div',{id:'grid',style:{marginTop:'8px'}},'Coming online…')));
    // This is a placeholder – to show everyone live, add a /api/users proxy and loop users here.
    // For now we just show “me”.
    try{
      const me = await whoami(); 
      const today=isoDate(new Date());
      const container=qs('#grid'); container.innerHTML='';
      const s=await getSchedule(me.username,today);
      const ev=await listEvents(me.username,today,today);
      const card=el('div',{class:'card'},
        el('div',{style:{display:'flex',justifyContent:'space-between'}}, el('strong',{},me.username), el('span',{class:'help'},'today')),
        buildBars(today,s?.blocks||[],Array.isArray(ev)?ev:[])
      );
      container.append(card);
    }catch{ qs('#grid').textContent='Unable to load now.'; }
  }

  /* --- History tab --- */
  function showHistory(){
    const host=qs('#pane'); host.innerHTML='';
    host.append(el('div',{class:'card'},
      el('div',{class:'grid grid-2'},
        el('div',{}, el('div',{class:'label'},'Agent'), el('input',{id:'hUser',class:'field',placeholder:'username'})),
        el('div',{}, el('div',{class:'label'},'Date'), el('input',{id:'hDay',class:'field',type:'date',value:isoDate(new Date())}))),
      el('div',{style:{marginTop:'10px'}},
        el('button',{class:'btn',onclick:run},'Run')),
      el('div',{id:'out',style:{marginTop:'10px'}})
    ));

    async function run(){
      const u=qs('#hUser').value.trim(); const d=qs('#hDay').value||isoDate(new Date());
      const out=qs('#out'); out.textContent='Loading…';
      if(!u){ out.textContent='Enter a username.'; return; }
      try{
        const s=await getSchedule(u,d); const ev=await listEvents(u,d,d);
        out.innerHTML='';
        out.append(buildBars(d,s?.blocks||[],Array.isArray(ev)?ev:[]));
      }catch(e){ out.textContent='Error loading history.'; }
    }
  }

  showSchedule(); // default
}

/* --------------- boot --------------- */
(async ()=>{
  const r = await fetch('/api/whoami',{credentials:'include'});
  if(!r.ok){ location.href='/hub'; return; }
  const me=await r.json();
  if(me.role==='AGENT'){ mountAgent(me); } else { mountAdmin(me); }
})();
</script>
</body>
</html>
