<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Allstar Agent Adherence</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --brand:#e11d48; --brand-ink:#fff;
      --bg:#ffffff; --ink:#0f172a; --muted:#6b7280; --line:#e5e7eb;
      --chip:#f8fafc; --chip-ink:#0f172a; --shadow:0 10px 25px rgba(17,24,39,.08);
      --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
    .page{min-height:100vh;display:flex;flex-direction:column}
    .header{position:sticky;top:0;z-index:10;backdrop-filter:blur(6px);background:rgba(255,255,255,.9);border-bottom:1px solid var(--line)}
    .header-inner{max-width:1200px;margin:0 auto;display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 20px}
    .hl{display:flex;align-items:center;gap:10px}
    .logoimg{height:28px;width:auto;border-radius:8px}
    .brand{font-weight:900;letter-spacing:.3px;color:var(--brand);font-size:18px}
    .pill{display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;background:#fee2e2;color:#b91c1c;font-size:12px;border:1px solid #fecaca}
    .main{max-width:1200px;margin:0 auto;padding:20px;flex:1;width:100%}
    .grid{display:grid;gap:20px}
    @media (min-width:1000px){ .grid-2{grid-template-columns:2fr 1fr} }
    .card{background:#fff;border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
    .card h2{margin:0 0 8px 0}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .row-wrap{display:flex;flex-wrap:wrap;gap:10px}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid var(--line);background:#fff;cursor:pointer;color:inherit;text-decoration:none;box-shadow:var(--shadow)}
    .btn:hover{background:#fafafa}
    .btn-brand{background:var(--brand);border-color:transparent;color:#fff;font-weight:700}
    .btn-brand:hover{filter:brightness(.97)}
    .btn-danger{border-color:#fecaca;color:#b91c1c;background:#fff}
    .btn-danger:hover{background:#fff5f5}
    .btn-small{padding:6px 8px;border-radius:10px}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;font-size:12px}
    .badge.good{background:#dcfce7;color:#166534}
    .badge.bad{background:#fee2e2;color:#b91c1c}
    .badge.neutral{background:#f1f5f9;color:#334155}
    .fieldset{display:flex;flex-wrap:wrap;gap:8px}
    input,select{border:1px solid var(--line);border-radius:10px;padding:8px 10px;font:inherit}
    .meter{width:100%;height:10px;background:#f1f5f9;border-radius:999px;overflow:hidden;border:1px solid var(--line)}
    .meter > div{height:100%}

    .bar-wrap{flex:1}
    .bar{position:relative;border:1px solid var(--line);background:#fff;border-radius:10px;overflow:hidden;height:28px}
    .bar .seg{position:absolute;top:0;bottom:0;opacity:.55}
    .bar .seg.actual{opacity:.7}
    .bar .now{position:absolute;top:0;bottom:0;width:2px;background:#0f172a}

    /* NEW: give the ticks more bottom room, and add bigger gap before the second bar */
    .ticks{position:relative;height:18px; margin-top:8px}
    .tick{position:absolute;top:0;bottom:0;width:1px;background:#e5e7eb}
    .tick-label{position:absolute;top:18px;transform:translateX(-50%);font-size:10px;color:#64748b}

    .legend{display:flex;flex-wrap:wrap;gap:10px}
    .chip{display:flex;align-items:center;gap:6px;font-size:12px}
    .dot{width:10px;height:10px;border-radius:999px}
    .list{max-height:220px;overflow:auto;border:1px solid var(--line);border-radius:12px;padding:8px}
    .list li{display:flex;align-items:center;gap:10px;padding:6px 0;border-bottom:1px solid #f1f5f9}
    .list li:last-child{border-bottom:0}
    .status-btn{display:flex;align-items:center;gap:8px;padding:10px;border:1px solid #fecaca;border-radius:12px;background:#fff}
    .status-btn:hover{background:#fff5f5}
    .footer{padding:16px 20px;color:var(--muted);border-top:1px solid var(--line);text-align:center;font-size:12px;margin-top:20px}
    .errbar{position:fixed;left:20px;right:20px;bottom:16px;z-index:60;background:#fef2f2;color:#991b1b;border:1px solid #fecaca;border-radius:12px;padding:10px 12px;box-shadow:var(--shadow);display:none}
    .exports{display:flex;flex-wrap:wrap;gap:8px}
    .hidden{display:none!important}
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <div id="errbar" class="errbar"></div>

  <script type="text/babel">
    const {useEffect,useMemo,useState,useRef} = React;

    /*********** Config ***********/
    const STATUS_DEFS = {
      available:{label:"Available",color:"#16a34a"},
      bathroom:{label:"Bathroom",color:"#f59e0b"},
      break:{label:"Break",color:"#facc15"},
      lunch:{label:"Lunch",color:"#fb923c"},
      training:{label:"Training",color:"#6366f1"},
      meeting:{label:"Meeting",color:"#3b82f6"},
      offline:{label:"Offline",color:"#9ca3af"},
    };
    const DEFAULT_STATUSES = Object.keys(STATUS_DEFS);

    /*********** Helpers ***********/
    const isoDate = (d)=> new Date(d.getFullYear(), d.getMonth(), d.getDate()).toISOString().slice(0,10);
    const todayStr = ()=> isoDate(new Date());
    const hhmmToMinutes = (hhmm)=>{ const [h,m]=hhmm.split(":").map(Number); return h*60+m; };
    const nowMinutes = ()=> { const d=new Date(); return d.getHours()*60 + d.getMinutes(); };
    const minuteToMs = (minuteOfDay, dateStr)=> new Date(`${dateStr}T00:00:00`).getTime() + minuteOfDay*60000;
    const getBounds = (dateStr)=>{ const s=new Date(`${dateStr}T00:00:00`).getTime(); return {start:s,end:s+86400000}; };
    const fmtHm = (d)=> new Date(d).toLocaleTimeString([], {hour:"2-digit",minute:"2-digit",second:"2-digit"});
    const within = (ts, {start,end}) => ts>=start && ts<=end;
    const fmtHMS = (ms)=>{ const sec=Math.max(0,Math.floor(ms/1000)); const h=String(Math.floor(sec/3600)).padStart(2,"0"); const m=String(Math.floor((sec%3600)/60)).padStart(2,"0"); const s=String(sec%60).padStart(2,"0"); return `${h}:${m}:${s}`; };

    const LS_KEY = (u,d)=> `adh_events_v1:${u}:${d}`;
    const loadLS = (u,d)=>{ try{ const raw=localStorage.getItem(LS_KEY(u,d)); const arr=raw?JSON.parse(raw):[]; return Array.isArray(arr)? arr : []; }catch{return [];} };
    const saveLS = (u,d,ev)=>{ try{ localStorage.setItem(LS_KEY(u,d), JSON.stringify(ev||[])); }catch{} };

    function mergeEvents(prev, incoming, bounds){
      const key = (e)=> `${e.ts}-${e.status}`;
      const map = new Map();
      [...(prev||[]), ...(incoming||[])]
        .filter(e => e && typeof e.ts==='number' && within(e.ts, bounds))
        .forEach(e => { map.set(key(e), e); });
      return Array.from(map.values()).sort((a,b)=>a.ts-b.ts);
    }

    /*********** API ***********/
    async function api(path, opts={}){
      const r = await fetch(path, {credentials:"include", ...opts, headers:{ "content-type":"application/json", ...(opts.headers||{}) }});
      const ct = r.headers.get("content-type")||"";
      const body = ct.includes("json") ? await r.json() : await r.text();
      if (!r.ok) { const e = new Error("api_error"); e.status=r.status; e.body=body; throw e; }
      return body;
    }
    const whoami = ()=> api("/api/whoami").catch(()=>({authed:false}));
    const getSchedule = (user,date)=> api(`/api/schedules?user=${encodeURIComponent(user)}&date=${encodeURIComponent(date)}`);
    const saveSchedule = (user,date,blocks)=> api(`/api/schedules`, {method:"POST", body: JSON.stringify({ user, date, blocks })});
    async function listEvents(user, fromMs, toMs){
      try{
        return await api(`/api/events?user=${encodeURIComponent(user)}&from=${fromMs}&to=${toMs}`);
      }catch(e){
        return api(`/api/presence?user=${encodeURIComponent(user)}&from=${fromMs}&to=${toMs}`);
      }
    }
    async function pushEvent(user, status, tsMs){
      try{
        return await api(`/api/events`, {method:"POST", body: JSON.stringify({ user, status, ts: tsMs })});
      }catch(e){
        return api(`/api/presence`, {method:"POST", body: JSON.stringify({ user, status, ts: tsMs })});
      }
    }

    /*********** Domain ***********/
    function expectedAt(schedule, m){
      for (const blk of (schedule||[])){
        const s = hhmmToMinutes(blk.start), e = hhmmToMinutes(blk.end);
        if (m>=s && m<e) return blk.status;
      }
      return null;
    }
    function statusAtTs(events, tsMs){
      const ev=(events||[]).slice().sort((a,b)=>a.ts-b.ts);
      let cur = null;
      for (let i=0;i<ev.length;i++){
        if (ev[i].ts<=tsMs) cur = ev[i].status; else break;
      }
      return cur;
    }

    function computeAdherenceRange(schedule, events, startMin, endMin, dateStr){
      const ev = (events||[]).slice().sort((a,b)=>a.ts-b.ts);
      const minuteActual = new Array(Math.max(0,endMin-startMin)).fill(null);
      let cur = ev.length? ev[0].status : null;
      let idx=0;
      for(let m=startMin;m<endMin;m++){
        const ms = minuteToMs(m,dateStr);
        while (idx+1<ev.length && ev[idx+1].ts<=ms){ idx++; cur=ev[idx].status; }
        minuteActual[m-startMin]=cur;
      }
      let inMin=0, outMin=0;
      for(let m=startMin;m<endMin;m++){
        const exp = expectedAt(schedule,m);
        if (!exp) continue;
        const act = minuteActual[m-startMin];
        if (!act) { outMin++; continue; }
        (act===exp)? inMin++ : outMin++;
      }
      const total = inMin+outMin;
      const pct = total? Math.round((inMin/total)*100) : 0;
      return {inMin,outMin,total,pct};
    }

    function computeLiveAdherence(schedule, events, dateStr){
      const minStart = schedule?.length ? Math.min(...schedule.map(b=>hhmmToMinutes(b.start))) : 8*60;
      const maxEnd   = schedule?.length ? Math.max(...schedule.map(b=>hhmmToMinutes(b.end))) : 17*60;
      const nowMin = nowMinutes();
      if (nowMin < minStart) return {inMin:0,outMin:0,total:0,pct:0, before:true};
      const endMin = Math.max(minStart, Math.min(maxEnd, nowMin));
      let res = computeAdherenceRange(schedule, events, minStart, endMin, dateStr);
      if (res.total === 0) {
        const exp = expectedAt(schedule, nowMin);
        const act = statusAtTs(events, Date.now());
        const inNow  = exp && act && exp===act ? 1 : 0;
        const outNow = exp ? (inNow?0:1) : 0;
        const total = inNow + outNow;
        const pct   = total ? Math.round(inNow/total*100) : 0;
        res = {inMin:inNow, outMin:outNow, total, pct};
      }
      res.pct = Math.max(0, Math.min(100, res.pct));
      return res;
    }

    // Build 24h expected segments, filling gaps with offline
    function assembleExpectedBlocks24h(schedule, dateStr){
      const segs = (schedule||[]).map(b=>({start:hhmmToMinutes(b.start), end:hhmmToMinutes(b.end), status:b.status}));
      segs.sort((a,b)=>a.start-b.start);
      const full=[];
      let cursor=0;
      for (const s of segs){
        if (s.start>cursor){ full.push({start:cursor,end:s.start,status:'offline'}); }
        full.push({start:s.start,end:s.end,status:s.status});
        cursor = Math.max(cursor, s.end);
      }
      if (cursor<1440) full.push({start:cursor,end:1440,status:'offline'});
      return full.map(x=>({startMs: minuteToMs(x.start, dateStr), endMs: minuteToMs(x.end, dateStr), status:x.status}));
    }

    // NEW: Actual blocks only up to "now" (no future painting)
    function assembleActualBlocksPastOnly(events, dayStartMs, dayEndMs, nowMs){
      const ev=(events||[]).slice().sort((a,b)=>a.ts-b.ts);
      const until = Math.min(dayEndMs, nowMs);
      let cur = statusAtTs(ev, dayStartMs) || 'offline';
      let curStart = dayStartMs;
      const out=[];
      for (let i=0;i<ev.length;i++){
        const e=ev[i];
        if (e.ts < dayStartMs) continue;
        if (e.ts > until) break;
        if (curStart < e.ts){
          out.push({start:curStart,end:e.ts,status:cur});
          curStart = e.ts;
        }
        cur = e.status || 'offline';
      }
      if (curStart < until){
        out.push({start:curStart,end:until,status:cur});
      }
      return out;
    }

    function currentStatusStartTs(events, dateStr){
      const {start:dayStart} = getBounds(dateStr);
      const now = Date.now();
      const ev = (events||[]).slice().sort((a,b)=>a.ts-b.ts);
      let lastChange = null;
      for (let i=ev.length-1;i>=0;i--){
        if (ev[i].ts <= now && ev[i].ts >= dayStart){ lastChange = ev[i].ts; break; }
      }
      if (lastChange !== null) return lastChange;
      const carried = statusAtTs(events, dayStart);
      if (carried) return dayStart;
      return null;
    }

    /*********** Components ***********/
    const Pill = ({kind="neutral",children})=>{
      const cls = kind==="good"?"badge good": kind==="bad"?"badge bad": "badge neutral";
      return <span className={cls}>{children}</span>;
    };

    const Meter = ({value})=>{
      const col = value>=95? "#16a34a" : value>=85? "#f59e0b" : "#ef4444";
      return <div className="meter"><div style={{width:`${Math.min(100,Math.max(0,value))}%`,background:col}}></div></div>;
    };

    const StatusLegend = ()=>(
      <div className="legend">
        {DEFAULT_STATUSES.map(s=>(
          <div key={s} className="chip">
            <span className="dot" style={{background:STATUS_DEFS[s].color}}></span>
            <span style={{fontSize:13}}>{STATUS_DEFS[s].label}</span>
          </div>
        ))}
      </div>
    );

    const DualBars = ({schedule, events, dateStr})=>{
      const [, setTick] = useState(0);
      useEffect(()=>{ const id=setInterval(()=>setTick(t=>t+1),1000); return ()=>clearInterval(id); },[]);

      const dayStart = minuteToMs(0, dateStr), dayEnd=minuteToMs(1440, dateStr);
      const expectedBlocks = assembleExpectedBlocks24h(schedule, dateStr);

      const now = Date.now();
      const actualPast = assembleActualBlocksPastOnly(events, dayStart, dayEnd, now);

      const pct = (l,r)=> ((r-l)/(dayEnd-dayStart))*100;
      const leftPctMs=(ms)=> ((ms-dayStart)/(dayEnd-dayStart))*100;

      const hours = new Array(25).fill(0).map((_,i)=>i);
      const labelFor = (h)=> new Date(dayStart + h*3600000).toLocaleTimeString([], {hour:'2-digit'});

      return (
        <div className="bar-wrap">
          {/* Projected (24h continuous) */}
          <div className="row" style={{gap:10}}>
            <div style={{width:80,fontSize:12,color:"#374151"}}>Projected</div>
            <div style={{flex:1}}>
              <div className="bar">
                {expectedBlocks.map((b,i)=>{
                  const l=leftPctMs(b.startMs), w=pct(b.startMs, b.endMs);
                  return <div key={i} className="seg" style={{left:`${l}%`, width:`${w}%`, background:STATUS_DEFS[b.status]?.color, opacity:b.status==='offline'? .35:.35}} />;
                })}
                {(now>=dayStart && now<=dayEnd) && <div className="now" style={{left:`${leftPctMs(now)}%`}}></div>}
              </div>
              <div className="ticks">
                {hours.map(h=>{
                  const x=leftPctMs(dayStart + h*3600000);
                  return (
                    <React.Fragment key={h}>
                      <div className="tick" style={{left:`${x}%`}}></div>
                      {(h%2===0) && <div className="tick-label" style={{left:`${x}%`}}>{labelFor(h)}</div>}
                    </React.Fragment>
                  );
                })}
              </div>
            </div>
          </div>

          {/* Actual (24h) — background offline full width, then ONLY past segments up to now */}
          <div className="row" style="
            gap:10;
            margin-top:26px;  /* NEW: extra spacing so it won't overlap the first bar's tick labels */
          ">
            <div style={{width:80,fontSize:12,color:"#374151"}}>Actual</div>
            <div style={{flex:1}}>
              <div className="bar">
                {/* background offline layer across the whole day */}
                <div className="seg actual" style="left:0;right:0;width:100%;background:#9ca3af;opacity:.18"></div>
                {/* paint only the past blocks up to 'now' */}
                {actualPast.map((b,i)=>{
                  const l=leftPctMs(b.start), w=pct(b.start, b.end);
                  return <div key={i} className="seg actual" style={{left:`${l}%`, width:`${w}%`, background:STATUS_DEFS[b.status]?.color}} />;
                })}
                {(now>=dayStart && now<=dayEnd) && <div className="now" style={{left:`${leftPctMs(now)}%`}}></div>}
              </div>
              <div className="ticks">
                {hours.map(h=>{
                  const x=leftPctMs(dayStart + h*3600000);
                  return (
                    <React.Fragment key={h}>
                      <div className="tick" style={{left:`${x}%`}}></div>
                      {(h%2===0) && <div className="tick-label" style={{left:`${x}%`}}>{labelFor(h)}</div>}
                    </React.Fragment>
                  );
                })}
              </div>
            </div>
          </div>
        </div>
      );
    };

    /*********** Screens ***********/
    function AgentView({ me, dateStr, schedule, events, onSetStatus }){
      const live = computeLiveAdherence(schedule, events, dateStr);

      const [tick, setTick] = useState(0);
      useEffect(()=>{ const id=setInterval(()=>setTick(t=>t+1),1000); return ()=>clearInterval(id); },[]);
      const tsStart = useMemo(()=> currentStatusStartTs(events, dateStr), [events, dateStr]);
      const hasCurrent = tsStart !== null;
      const elapsedMs = hasCurrent ? (Date.now() - tsStart) : 0;

      const nowMin = nowMinutes();
      const expectedNow = expectedAt(schedule, nowMin);
      const current = statusAtTs(events, Date.now());
      const inAdh = !!expectedNow && current === expectedNow;

      const {start:dayStart,end:dayEnd} = getBounds(dateStr);
      const recent = (events||[])
        .filter(e => within(e.ts,{start:dayStart,end:dayEnd}))
        .sort((a,b)=>b.ts-a.ts)
        .reduce((acc, e)=>{
          if (!acc.length || acc[acc.length-1].status !== e.status) acc.push(e);
          return acc;
        }, [])
        .slice(0,50);

      return (
        <div className="grid grid-2">
          <div className="card">
            <div className="row">
              <h2>Real-time Adherence</h2>
              <div className="row-wrap">
                <Pill kind={inAdh?"good":"bad"}>{inAdh? "In Adherence":"Out of Adherence"}</Pill>
                <Pill>{expectedNow ? `Expected: ${STATUS_DEFS[expectedNow]?.label}` : "Expected: —"}</Pill>
                <Pill>{current ? `Current: ${STATUS_DEFS[current]?.label}` : "Current: —"}</Pill>
                <Pill>{hasCurrent ? `Time in status: ${fmtHMS(elapsedMs)}` : "Time in status: —"}</Pill>
              </div>
            </div>

            <div className="row" style={{gap:12, margin:"8px 0"}}>
              <Meter value={live.pct} />
              <div style={{fontSize:13,color:"#374151"}}><strong>{live.pct}%</strong></div>
            </div>

            <DualBars schedule={schedule} events={events} dateStr={dateStr} />
          </div>

          <div className="card">
            <h2>Set Status</h2>
            <div className="row-wrap">
              {DEFAULT_STATUSES.map(s=>(
                <button key={s} className="status-btn" onClick={()=> onSetStatus(s)}>
                  <span className="dot" style={{background:STATUS_DEFS[s].color}}></span>
                  <span style={{fontSize:14}}>{STATUS_DEFS[s].label}</span>
                </button>
              ))}
            </div>

            <div style={{height:12}}></div>
            <h3 style={{margin:"0 0 6px 0"}}>Recent Switches</h3>
            <ul className="list">
              {recent.map((e,i)=>(
                <li key={i}>
                  <span className="dot" style={{background:STATUS_DEFS[e.status]?.color}}></span>
                  <span className="pill">{fmtHm(e.ts)}</span>
                  <span style={{color:"#475569"}}>→ {STATUS_DEFS[e.status]?.label}</span>
                </li>
              ))}
              {(!recent || !recent.length) && <li className="muted">No events yet today.</li>}
            </ul>
            <div style={{height:6}}></div>
            <StatusLegend/>
          </div>
        </div>
      );
    }

    function AdminView({ allUsers, selectedUser, setSelectedUser, dateStr, setDateStr, schedule, events, adherence, perStatus, timeline, onAddBlock, onUpdateBlock, onDeleteBlock, onSaveSchedule }){
      return (
        <div className="grid grid-2">
          <div className="card">
            <div className="row">
              <h2>Active Calendar</h2>
              <div className="fieldset">
                <select value={selectedUser} onChange={e=>setSelectedUser(e.target.value)}>
                  <option value="">Select agent…</option>
                  {allUsers.map(u => <option key={u.username||u} value={(u.username||u)}>{u.username||u}</option>)}
                </select>
                <input type="date" value={dateStr} onChange={e=>setDateStr(e.target.value)} />
              </div>
            </div>

            <div style={{height:8}}></div>
            <h3 style={{margin:"0 0 8px 0"}}>Projected vs Actual (24h)</h3>
            <DualBars schedule={schedule} events={events} dateStr={dateStr} />
            <div className="row" style={{marginTop:8}}>
              <div>Adherence: <strong>{adherence.pct}%</strong> <span className="muted">({adherence.inMin} in · {adherence.outMin} out)</span></div>
            </div>

            <div style={{height:8}}></div>
            <h3 style={{margin:"0 0 6px 0"}}>AUX Totals (day)</h3>
            <ul className="row-wrap" style={{gap:8}}>
              {Object.entries(perStatus).sort((a,b)=>b[1]-a[1]).map(([s,mins])=>(
                <li key={s} className="badge" style={{background:"#f8fafc",color:"#334155",border:"1px solid var(--line)"}}>
                  <span className="dot" style={{background:STATUS_DEFS[s]?.color}}></span>
                  <span>{STATUS_DEFS[s]?.label||s}</span>
                  <span>— {mins>=60?`${Math.floor(mins/60)}h ${Math.round(mins%60)}m`:`${Math.round(mins)}m`}</span>
                </li>
              ))}
              {!Object.keys(perStatus).length && <li className="muted">No time recorded.</li>}
            </ul>

            <div style={{height:8}}></div>
            <h3 style={{margin:"0 0 6px 0"}}>IMED-style Timeline</h3>
            <ul className="list">
              {timeline.sort((a,b)=>a.start-b.start).map((t,i)=>(
                <li key={i}>
                  <span className="pill" style={{background:"#f1f5f9",color:"#334155",border:"1px solid var(--line)"}}>{fmtHm(t.start)}</span>
                  <span className="dot" style={{background:STATUS_DEFS[t.status]?.color}}></span>
                  <span style={{color:"#334155"}}>{STATUS_DEFS[t.status]?.label||t.status}</span>
                  <span className="muted">— {t.minutes>=60?`${Math.floor(t.minutes/60)}h ${Math.round(t.minutes%60)}m`:`${Math.round(t.minutes)}m`}</span>
                </li>
              ))}
              {!timeline.length && <li className="muted">No segments.</li>}
            </ul>
          </div>

          <div className="card">
            <div className="row">
              <h2>Schedule Editor</h2>
              <button className="btn btn-brand btn-small" onClick={onAddBlock} disabled={!selectedUser}>+ Block</button>
            </div>
            {!selectedUser && <div className="muted">Select a user to edit today’s schedule.</div>}
            {selectedUser && (
              <div className="row-wrap" style={{gap:8}}>
                {schedule.map((blk,i)=>(
                  <div key={i} className="row-wrap" style={{gap:6,alignItems:"center",border:"1px solid var(--line)",padding:8,borderRadius:10}}>
                    <select value={blk.status} onChange={e=>onUpdateBlock(i,"status",e.target.value)}>
                      {DEFAULT_STATUSES.map(s=>(<option key={s} value={s}>{STATUS_DEFS[s].label}</option>))}
                    </select>
                    <input value={blk.start} onChange={e=>onUpdateBlock(i,"start",e.target.value)} placeholder="HH:MM" />
                    <input value={blk.end}   onChange={e=>onUpdateBlock(i,"end",e.target.value)}   placeholder="HH:MM" />
                    <button className="btn btn-small btn-danger" onClick={()=>onDeleteBlock(i)}>Delete</button>
                  </div>
                ))}
                {!schedule.length && <div className="muted">No blocks. Add one to begin.</div>}
                <div style={{width:"100%",display:"flex",justifyContent:"flex-end",marginTop:8}}>
                  <button className="btn btn-brand" onClick={onSaveSchedule} disabled={!selectedUser}>Save Schedule</button>
                </div>
              </div>
            )}

            <div style={{height:12}}></div>
            <h3 style={{margin:"0 0 6px 0"}}>Exports</h3>
            <div className="exports">
              <a className="btn btn-small" href="#" id="expDay">Events (Day)</a>
              <a className="btn btn-small" href="#" id="expWeek">Events (Week)</a>
              <a className="btn btn-small" href="#" id="expMonth">Events (Month)</a>
              <a className="btn btn-small" href="#" id="expSched">Schedules (Month)</a>
              <a className="btn btn-small" href="#" id="expAdh">Adherence (Month)</a>
            </div>
          </div>
        </div>
      );
    }

    /*********** App ***********/
    function App(){
      const [me,setMe] = useState(null);
      const [role,setRole] = useState("AGENT");

      const [dateStr,setDateStr] = useState(todayStr());
      const [selectedUser,setSelectedUser] = useState("");

      const [schedule,setSchedule]=useState([]);
      const [events,setEvents]=useState([]);

      const adherence = useMemo(()=>{
        const minStart = schedule?.length ? Math.min(...schedule.map(b=>hhmmToMinutes(b.start))) : 8*60;
        const maxEnd   = schedule?.length ? Math.max(...schedule.map(b=>hhmmToMinutes(b.end))) : 17*60;
        return computeAdherenceRange(schedule, events, minStart, maxEnd, dateStr);
      }, [schedule, events, dateStr]);

      const auxAgg = useMemo(()=>{
        const {start,end}=getBounds(dateStr);
        const ev=(events||[]).slice().sort((a,b)=>a.ts-b.ts);
        let cur=null, curStart=start;
        for (let i=0;i<ev.length;i++){ if (ev[i].ts<=start){ cur=ev[i].status; curStart=start; } else break; }
        const per={}, timeline=[];
        for (let i=0;i<ev.length && ev[i].ts<end;i++){
          const e=ev[i];
          const segEnd=Math.min(e.ts,end);
          if (cur){
            const mins=Math.max(0,Math.floor((Math.min(segEnd,Date.now())-curStart)/60000));
            if(mins){
              per[cur] = (per[cur] || 0) + mins;
              timeline.push({start:curStart,end:segEnd,status:cur,minutes:mins});
            }
          }
          cur=e.status; curStart=e.ts;
        }
        const hardEnd=Math.min(end,Date.now());
        if (cur && curStart<hardEnd){
          const mins=Math.max(0,Math.floor((hardEnd-curStart)/60000));
          per[cur] = (per[cur] || 0) + mins;
          timeline.push({start:curStart,end:hardEnd,status:cur,minutes:mins});
        }
        return {perStatus:per,timeline};
      }, [events, dateStr]);

      const [users,setUsers]=useState([]);

      const errRef=useRef(""); const errDiv=useRef(null);
      useEffect(()=>{ errDiv.current = document.getElementById("errbar"); },[]);
      function showErr(msg){
        if(!errDiv.current) return;
        errRef.current = String(msg||"");
        errDiv.current.textContent = errRef.current;
        errDiv.current.style.display = errRef.current ? "block" : "none";
      }

      useEffect(()=>{
        (async()=>{
          try{
            const w = await whoami();
            const authed = w?.authed || w?.username || w?.role;
            if(!authed){ location.replace("/"); return; }
            const you = w.me ? w.me : w;
            setMe(you);
            const r = (you.role||"AGENT").toUpperCase();
            setRole(r);
            setSelectedUser(r==="ADMIN" ? (you.defaultUser||you.username) : you.username);
            try{
              const ul = await api("/api/users");
              const arr = Array.isArray(ul) ? ul : (ul?.users || []);
              if (arr?.length) setUsers(arr);
              else setUsers([{username: you.username}]);
            }catch{ setUsers([{username: you.username}]); }
          }catch(e){
            showErr("Unable to verify session. Please sign in again.");
            setTimeout(()=>location.replace("/"), 1200);
          }
        })();
      },[]);

      async function refetch(){
        try{
          if(!selectedUser || !dateStr) return;
          const sch = await getSchedule(selectedUser,dateStr);
          setSchedule(Array.isArray(sch) ? sch : (sch.blocks||[]));
        }catch(e){ showErr("Failed to load schedule."); }
        try{
          const {start,end}=getBounds(dateStr);
          const ev = await listEvents(selectedUser, start, end);
          const incoming = Array.isArray(ev) ? ev : (ev.events||[]);
          setEvents(prev => {
            const merged = mergeEvents(prev, incoming, {start, end});
            saveLS(selectedUser, dateStr, merged);
            return merged;
          });
        }catch(e){ showErr("Failed to load events."); }
      }

      useEffect(()=>{
        if (!selectedUser || !dateStr) return;
        setEvents(loadLS(selectedUser, dateStr));
        refetch();
      }, [selectedUser, dateStr]);

      useEffect(()=>{
        const id = setInterval(()=> refetch(), 15000);
        return ()=> clearInterval(id);
      }, [selectedUser, dateStr]);

      async function setStatus(s){
        try{
          const {start,end}=getBounds(dateStr);
          const ts = Date.now();
          if (within(ts,{start,end})) {
            setEvents(prev => {
              const merged = mergeEvents(prev, [{status:s, ts}], {start,end});
              saveLS(selectedUser, dateStr, merged);
              return merged;
            });
          }
          await pushEvent(me.username, s, ts);
          setTimeout(()=>{ refetch(); }, 1000);
        }catch(e){
          showErr("Could not update status (check session/CORS).");
        }
      }

      function addBlock(){
        setSchedule(prev=>{
          const lastEnd = prev?.length ? prev[prev.length-1].end : "08:00";
          return [...(prev||[]), {status:"available", start:lastEnd, end:lastEnd}];
        });
      }
      function updateBlock(i, field, val){
        setSchedule(prev=>{
          const next=[...(prev||[])]; next[i]={...next[i],[field]:val}; return next;
        });
      }
      function deleteBlock(i){
        setSchedule(prev=>{ const next=[...(prev||[])]; next.splice(i,1); return next; });
      }
      async function saveBlocks(){
        try{
          await saveSchedule(selectedUser, dateStr, schedule);
          refetch();
        }catch(e){ showErr("Saving schedule failed."); }
      }

      if (!me) return null;

      const header = (
        <div className="header">
          <div className="header-inner">
            <div className="hl">
              <img className="logoimg" src="/allstar-logo.png" alt="Allstar" onError={(e)=> e.currentTarget.style.display='none'} />
              <div className="brand">Allstar Agent Adherence</div>
              <span className="pill">Real-time</span>
            </div>
            <div className="hl">
              <span style={{fontSize:13,color:"#475569"}}>Logged in as <strong>{me.username}</strong> · <span style={{textTransform:'capitalize'}}>{(me.role||'agent').toLowerCase()}</span></span>
              <a className="btn" href="/hub.html">Back to Hub</a>
              <a className="btn btn-danger" href="/api/logout">Sign out</a>
            </div>
          </div>
        </div>
      );

      return (
        <div className="page">
          {header}
          <main className="main">
            {role==="ADMIN" ? (
              <AdminView
                allUsers={users}
                selectedUser={selectedUser}
                setSelectedUser={setSelectedUser}
                dateStr={dateStr}
                setDateStr={setDateStr}
                schedule={schedule}
                events={events}
                adherence={adherence}
                perStatus={auxAgg.perStatus}
                timeline={auxAgg.timeline}
                onAddBlock={addBlock}
                onUpdateBlock={updateBlock}
                onDeleteBlock={deleteBlock}
                onSaveSchedule={saveBlocks}
              />
            ) : (
              <AgentView
                me={me}
                dateStr={dateStr}
                schedule={schedule}
                events={events}
                onSetStatus={setStatus}
              />
            )}
          </main>
          <div className="footer">© Allstar — Agent Hub</div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
  </script>
</body>
</html>
